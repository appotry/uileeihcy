#include "stdafx.h"
#include "customwindow.h"
#include "UISDK\Kernel\Src\Renderbase\renderbase\renderbase.h"
#include "UISDK\Kernel\Inc\Interface\imapattr.h"
#include "UISDK\Kernel\Src\RenderLayer\renderchain.h"
#include "UISDK\Kernel\Src\Util\dwm\dwmhelper.h"

#define WINDOWS_MINIMIZED_POINT  -32000  // 窗口最小化后，window传递给我们的位置

CustomWindow::CustomWindow()
{
    m_pICustomWindow = NULL;
	m_bNeedToSetWindowRgn = true;   // 首次显示时，需要设置一下窗口形状
	m_eTransparentRgnType = WINDOW_TRANSPARENT_PART_FULL;     
	m_nWindowTransparentMaskType = WINDOW_TRANSPARENT_TYPE_NULL;
	m_pColMask = NULL;
	m_nAlphaMask = 1;                    // 当alpha值为0时，将抠除
	m_TransparentRgn9Region.Set(0);

	m_hRgn_topleft = NULL;
	m_hRgn_topright = NULL;
	m_hRgn_bottomleft = NULL;
	m_hRgn_bottomright = NULL;

	this->m_nResizeBit = WRSB_CAPTION;
	this->m_pLayeredWindowWrap = NULL;		
}
CustomWindow::~CustomWindow()
{
	SAFE_DELETE_GDIOBJECT(m_hRgn_topleft);
	SAFE_DELETE_GDIOBJECT(m_hRgn_topright);
	SAFE_DELETE_GDIOBJECT(m_hRgn_bottomleft);
	SAFE_DELETE_GDIOBJECT(m_hRgn_bottomright);
	SAFE_RELEASE(m_pColMask);
	SAFE_DELETE(m_pLayeredWindowWrap);
}

BOOL  CustomWindow::PreCreateWindow(CREATESTRUCT* pcs)
{
    __super::nvProcessMessage(GetCurMsg(), 0, 0);
    if (FALSE == GetCurMsg()->lRet)
        return FALSE;

	pcs->style = DS_SETFONT | WS_POPUP | WS_SYSMENU /*| WS_THICKFRAME*/;
	if (m_pLayeredWindowWrap)
	{
		m_pLayeredWindowWrap->PreCreateWindow(pcs);
	}

	return TRUE;
}

void  CustomWindow::OnObjectLoaded()
{
    // 由于在SetAttribute中将自己设置为分层窗口时，子对象还都没有创建。因此在自己加载完成后
    // 通知下所有的子窗口
    if (m_pLayeredWindowWrap)
    {
        UIMSG  msg;
        msg.message = UI_WM_WINDOWLAYEREDCHANGED;
        msg.wParam = 1;
        ForwardMessageToChildObject(this, &msg);
    }
    SetMsgHandled(FALSE);
}
void CustomWindow::OnInnerInitWindow( )
{
	Window::OnInnerInitWindow();

	LONG dwStyleEx = GetWindowLong(m_hWnd, GWL_EXSTYLE );
	dwStyleEx &= ~ WS_EX_WINDOWEDGE;
	LONG n = SetWindowLong( m_hWnd, GWL_EXSTYLE, dwStyleEx );

	if (m_pLayeredWindowWrap)
		m_pLayeredWindowWrap->InitLayeredWindow();
}

GRAPHICS_RENDER_LIBRARY_TYPE  CustomWindow::OnGetGraphicsRenderType()
{
    if (m_nWindowTransparentMaskType & WINDOW_TRANSPARENT_TYPE_AREO ||
        m_nWindowTransparentMaskType & WINDOW_TRANSPARENT_TYPE_LAYERED ||
        this->IsTransparent())  //  例如多层渲染的控件层，需要被alphablend到缓冲上
        return GRAPHICS_RENDER_LIBRARY_TYPE_GDIPLUS;

    return GRAPHICS_RENDER_LIBRARY_TYPE_GDI; 
}

LRESULT CustomWindow::_OnNcDestroy( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
	bHandled = FALSE;
	if (m_pLayeredWindowWrap)
		m_pLayeredWindowWrap->ReleaseLayeredWindow();
	
	return 0;
}


//
// 屏蔽WM_NCACTIVATE消息，否则在win7上被激活或失活会有边框(但是因为现在不使用WS_THICKFRAME来实现拖拽，也没有这个
// 问题了，这里响应该消息仅为了实现窗口刷新）
// 20121127 后注:强制返回1将导致从一个模态customwindow中再弹出一个模态窗口时（如CFileDialog），新弹出的窗口将永远不能被激活。
//               貌似是子模态窗口会向父窗口发送这个消息进行检测
//
// Remark
//	Return Nonzero if Windows should proceed with default processing; 0 to prevent the caption bar or icon from being deactivated.
//
//	这里不能返回0，否则会导致其它窗口出现很多问题（--废弃）
//	
LRESULT CustomWindow::_OnNcActivate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	this->SetActive(wParam?true:false);

	bHandled = FALSE;
	return 0;

// 	this->UpdateObject();
// 	return 1;
}


//
// 对于分层窗口，在显示的时候需要重新更新一次。因为当分层窗口隐藏的时候内存位图没有得到更新，invisible false后，直接return了
//
// 注：在这里没有使用响应WM_SHOWWINDOW来通过分层窗口刷新，因为在响应WM_SHOWWINDOW的时候，IsWindowVisible还是FALSE
//     因此改用OnWindowPosChanged来得到窗口显示的时机，通过分层窗口刷新
//   
LRESULT CustomWindow::_OnWindowPosChanging( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
	bHandled = FALSE;
	LPWINDOWPOS lpWndPos = (LPWINDOWPOS)lParam;

	if (m_pLayeredWindowWrap)
	{
		m_pLayeredWindowWrap->OnWindowPosChanging(lpWndPos);
	}
	return 0;
}
//
//	通知分层窗口新的位置和大小
//
LRESULT CustomWindow::_OnWindowPosChanged( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
	bHandled = FALSE;
	LPWINDOWPOS lpWndPos = (LPWINDOWPOS)lParam;

	if (m_pLayeredWindowWrap)
	{
		m_pLayeredWindowWrap->OnWindowPosChanged(lpWndPos);
	}
	return 0;
}
LRESULT CustomWindow::_OnCancelMode( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
	bHandled = FALSE;

	if (m_pLayeredWindowWrap)
	{
		m_pLayeredWindowWrap->OnCancelMode();
	}
	return 0;
}

LRESULT  CustomWindow::_OnDwmCompositionChanged(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if (m_nWindowTransparentMaskType & WINDOW_TRANSPARENT_TYPE_AREO)
    {
        this->SetWindowAreo(true);  // 由该函数内部去判断areo是否可用
        m_bNeedToSetWindowRgn = true;
        this->UpdateObject();
    }
    return 0;
}

void CustomWindow::ResetAttribute()
{
	__super::ResetAttribute();

	m_bNeedToSetWindowRgn = true;  // 换肤时，重新更新窗口形状
	m_nWindowTransparentMaskType = WINDOW_TRANSPARENT_TYPE_NULL;
	m_eTransparentRgnType = WINDOW_TRANSPARENT_PART_FULL;
	m_TransparentRgn9Region.Set(0);

	SAFE_RELEASE(m_pColMask);
	m_nAlphaMask = 255;

	SAFE_DELETE_GDIOBJECT(m_hRgn_topleft);
	SAFE_DELETE_GDIOBJECT(m_hRgn_topright);
	SAFE_DELETE_GDIOBJECT(m_hRgn_bottomleft);
	SAFE_DELETE_GDIOBJECT(m_hRgn_bottomright);
}
void CustomWindow::SetAttribute(IMapAttribute* pMapAttrib, bool bReload )
{
    const TCHAR* szText = pMapAttrib->GetAttr(XML_WINDOW_TRANSPARENT_TYPE, true);
	if (szText)
	{
        if (0 == _tcscmp(XML_WINDOW_TRANSPARENT_TYPE_AREO, szText))
        {
            this->SetWindowAreo(true);
        }
		else if (0 == _tcscmp(XML_WINDOW_TRANSPARENT_TYPE_LAYERED, szText))
		{
			m_nWindowTransparentMaskType = WINDOW_TRANSPARENT_TYPE_LAYERED;
			this->SetWindowLayered(true);
		}
		else if (0 == _tcscmp(XML_WINDOW_TRANSPARENT_TYPE_MASKCOLOR, szText))
		{	
			m_nWindowTransparentMaskType = WINDOW_TRANSPARENT_TYPE_MASKCOLOR;
		}	
		else if (0 == _tcscmp(XML_WINDOW_TRANSPARENT_TYPE_MASKALPHA, szText))
		{
			m_nWindowTransparentMaskType = WINDOW_TRANSPARENT_TYPE_MASKALPHA;
		}

		// 透明色
        szText = pMapAttrib->GetAttr(XML_WINDOW_TRANSPARENT_TYPE_MASKCOLOR_VALUE, true);
		if (szText)
		{
			IColorRes* pColorRes = m_pUIApplication->GetActiveSkinColorRes();
			if (pColorRes)
				pColorRes->GetColor((BSTR)szText, &m_pColMask);

			m_nWindowTransparentMaskType |= WINDOW_TRANSPARENT_TYPE_MASKCOLOR;
		}

		// 透明度
        szText = pMapAttrib->GetAttr(XML_WINDOW_TRANSPARENT_TYPE_MASKALPHA_VALUE, true);
		if (szText)
		{
			m_nAlphaMask = _ttoi(szText);
			m_nWindowTransparentMaskType |= WINDOW_TRANSPARENT_TYPE_MASKALPHA;
		}
	}

    szText = pMapAttrib->GetAttr(XML_WINDOW_TRANSPARENT_PART, true);
    if (szText)
    {
        if (0 == _tcscmp(XML_WINDOW_TRANSPARENT_PART_4_CORNER, szText))
        {
            m_eTransparentRgnType = WINDOW_TRANSPARENT_PART_4_CORNER;
        }
        else if (0 == _tcscmp(XML_WINDOW_TRANSPARENT_PART_8_BORDER, szText))
        {
            m_eTransparentRgnType = WINDOW_TRANSPARENT_PART_8_BORDER;
        }
        else if (0 == _tcscmp(XML_WINDOW_TRANSPARENT_PART_FULL, szText))
        {
            m_eTransparentRgnType = WINDOW_TRANSPARENT_PART_FULL;
        }
        else if (0 == _tcscmp(XML_WINDOW_TRANSPARENT_PART_CUSTOM_CORNER, szText))
        {
            m_eTransparentRgnType = WINDOW_TRANSPARENT_PART_CUSTOM_CORNER;
        }
        else
        {
            m_eTransparentRgnType = WINDOW_TRANSPARENT_PART_NULL;
        }
    }

    // 获取设置参数
    if (m_eTransparentRgnType == WINDOW_TRANSPARENT_PART_4_CORNER ||
        m_eTransparentRgnType == WINDOW_TRANSPARENT_PART_8_BORDER ||
        m_eTransparentRgnType == WINDOW_TRANSPARENT_PART_CUSTOM_CORNER ||
        m_nWindowTransparentMaskType == WINDOW_TRANSPARENT_TYPE_AREO)
    {
        szText = pMapAttrib->GetAttr(XML_WINDOW_TRANSPARENT_PART_9REGION, true);
        if (szText)
        {
            Util::TranslateImage9Region(szText, &m_TransparentRgn9Region);
        }
        else
        {
            m_TransparentRgn9Region.Set(0);
        }
    }

	// 注：这里需要将设置分层窗口的属性放在前面。因为object中很多背景图依赖于窗口类型
	Window::SetAttribute(pMapAttrib, bReload);
}


void  CustomWindow::OnEditorGetAttrList(EDITORGETOBJECTATTRLISTDATA* pData)
{
    __super::OnEditorGetAttrList(pData);

    IUIEditor* pEditor = pData->pEditor;
    const TCHAR* szPrefix = pData->szPrefix;

    IUIEditorGroupAttribute*  pWindowGroup = pEditor->CreateGroupAttribute(pData->pGroupAttr, CustomWindow::GetXmlName(), NULL);
    pEditor->CreateComboBoxAttribute(pWindowGroup, XML_WINDOW_TRANSPARENT_TYPE, szPrefix)
        ->AddOption(L"", L"")
        ->AddOption(XML_WINDOW_TRANSPARENT_TYPE_LAYERED)
        ->AddOption(XML_WINDOW_TRANSPARENT_TYPE_AREO)
        ->AddOption(XML_WINDOW_TRANSPARENT_TYPE_MASKALPHA)
        ->AddOption(XML_WINDOW_TRANSPARENT_TYPE_MASKCOLOR);
    pEditor->CreateTextAttribute(pWindowGroup, XML_WINDOW_TRANSPARENT_TYPE_MASKCOLOR_VALUE, szPrefix);
    pEditor->CreateTextAttribute(pWindowGroup, XML_WINDOW_TRANSPARENT_TYPE_MASKALPHA_VALUE, szPrefix);
    pEditor->CreateTextAttribute(pWindowGroup, XML_WINDOW_TRANSPARENT_PART, szPrefix);
    pEditor->CreateTextAttribute(pWindowGroup, XML_WINDOW_TRANSPARENT_PART_9REGION, szPrefix);
}


// [Virtual]
// 1. 实现EraseBkgnd之后，UpdateWindowRgn
// 2. 另外由于一些情况下隐藏时也可能需要绘制（如分层窗口...)
bool CustomWindow::DrawObject(IRenderTarget* pRenderTarget, RenderContext roc)
{
    //if (this->IsVisible())  // 由于分层窗口在下次显示时不会先更新再显示，导致隐藏时作的刷新都没处理。因此将这里的隐藏去掉
    {
        ::UISendMessage(this->GetIMessage(), WM_ERASEBKGND, (WPARAM)pRenderTarget, (LPARAM)&roc );  // 将lparam置为1，与原始消息进行区分

        // 重新设置窗口透明形状 
        // 注：
        //    1. 不将该段代码放在OnErasebkgnd中的原因是，刷新一个按钮时也会走到
        // OnEraseBkgnd中，导致这时的背景图片中被剪裁只剩下一个控件，update window rgn错误。
        //    2. 同理，也不能放在CommitDoubleBuffet2Window中，因为也有可能是初始中刷新了一个对象
        //    3. 如果放在_OnPaint当中的话，则会将窗口上的文字由于采用GDI绘制alpha变成0，也会被抠掉

        if (m_bNeedToSetWindowRgn)
        {
            this->UpdateWindowRgn();
        }

        this->_drawNcChildObject(pRenderTarget, roc);

        roc.DrawClient(m_pIObject);
        roc.Scroll(m_pIObject);
        roc.Update(pRenderTarget);

        ::UISendMessage(this, WM_PAINT, (WPARAM)pRenderTarget, (LPARAM)&roc);       // 将lparam置为1，与原始消息进行区分
        this->DrawChildObject(pRenderTarget, roc);
    }

    return true;
}


// 屏蔽WM_PAINT消息，不需要绘制Nc (否则在拉伸CustomExWindow的时候会出现thickframe )
LRESULT CustomWindow::_OnNcPaint( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
	bHandled = TRUE;
	return 0;
}

void CustomWindow::OnEraseBkgnd(IRenderTarget* pRenderTarget)
{
	if (m_pBkgndRender || m_pForegndRender || m_pMaterialRender)
	{
		CRect rc(0,0, GetWidth(), GetHeight());

		int nState = this->IsActive()?WINDOW_BKGND_RENDER_STATE_ACTIVE:WINDOW_BKGND_RENDER_STATE_INACTIVE;

        if (m_pBkgndRender)
        {
            CRect rcBkgnd(&rc);
            rcBkgnd.DeflateRect(&m_rcBkgndRenderRegion);
            m_pBkgndRender->DrawState(pRenderTarget, &rcBkgnd, nState);
        }

        if (m_pMaterialRender)
        {
            CRect rcTextureRegion(&rc);
            rcTextureRegion.DeflateRect(&m_rcMaterialRenderRegion);
            m_pMaterialRender->DrawState(pRenderTarget, &rcTextureRegion, nState);
        }

        if (m_pForegndRender)
        {
            CRect rcForegnd(&rc);
            rcForegnd.DeflateRect(&m_rcForegndRenderRegion);
            m_pForegndRender->DrawState(pRenderTarget, &rcForegnd, nState);
        }
	}
	else
	{
		__super::OnEraseBkgnd(pRenderTarget);
	}
}

void CustomWindow::UpdateWindowRgn()
{
	this->m_bNeedToSetWindowRgn = false;

#if 0
	BYTE* pBits = LockBits(pRenderTarget);
	if (NULL == pBits)
		return;

	this->UpdateWindowRgn(pBits);

	UnlockBits(pRenderTarget);
#else

	HDC hMemDC = m_pRenderChain->GetMemoryDC();
	if (NULL == hMemDC)
		return;

	DIBSECTION  dibsection;
	HBITMAP hBitmap = (HBITMAP)::GetCurrentObject(hMemDC, OBJ_BITMAP);
	if (NULL == hBitmap)
		return;

	::GetObject(hBitmap, sizeof(DIBSECTION), &dibsection);
	this->UpdateWindowRgn((BYTE*)dibsection.dsBm.bmBits);

#endif
}

void CustomWindow::UpdateWindowRgn(BYTE* pBits)
{
	this->m_bNeedToSetWindowRgn = false;
	if (NULL == pBits)
	{
		return;
	}
	if (WINDOW_TRANSPARENT_TYPE_NULL == m_nWindowTransparentMaskType)
	{
		return;
	}
	if (WINDOW_TRANSPARENT_TYPE_LAYERED & m_nWindowTransparentMaskType ||
		WINDOW_TRANSPARENT_TYPE_NULL == m_nWindowTransparentMaskType)
	{
		return;   // 分层窗口不需要手动设置窗口形状
	}
    if (WINDOW_TRANSPARENT_TYPE_AREO & m_nWindowTransparentMaskType)
    {
        DwmHelper*  pDwm = DwmHelper::GetInstance();
        if (pDwm->IsEnable())
        {
            if (pDwm->pDwmEnableBlurBehindWindow)
            {
                CRect  rcClient;
                ::GetClientRect(m_hWnd, &rcClient);
                rcClient.DeflateRect(m_TransparentRgn9Region.left, m_TransparentRgn9Region.top, m_TransparentRgn9Region.right, m_TransparentRgn9Region.bottom);

                HRGN hRgn = CreateRectRgnIndirect(&rcClient);
                DWM_BLURBEHIND blurbehind = {0};
                blurbehind.dwFlags = DWM_BB_ENABLE|DWM_BB_BLURREGION|DWM_BB_TRANSITIONONMAXIMIZED;
                blurbehind.fEnable = TRUE;
                blurbehind.hRgnBlur = hRgn;
                blurbehind.fTransitionOnMaximized = TRUE;
                pDwm->pDwmEnableBlurBehindWindow(m_hWnd, &blurbehind);
                DeleteObject(hRgn);
            }
        }
        return;
    }

	switch (m_eTransparentRgnType)
	{
	case WINDOW_TRANSPARENT_PART_NULL:
		return;

	case WINDOW_TRANSPARENT_PART_FULL:
		{
			RECT rc = { 0, 0, this->GetWidth(), this->GetHeight() };
			HRGN hRgn = this->GetExcludeRgn(pBits, rc, false);
			if (hRgn)
			{
				HRGN hRgnFull = CreateRectRgnIndirect(&rc);
				::CombineRgn(hRgnFull,hRgnFull,hRgn, RGN_DIFF);
				::SetWindowRgn(m_hWnd,hRgnFull,::IsWindowVisible(m_hWnd));
				::DeleteObject(hRgn);
				::DeleteObject(hRgnFull);
			}
		}
		return;

	case WINDOW_TRANSPARENT_PART_4_CORNER:
		{
			int nWindowW = this->GetWidth();
			int nWindowH = this->GetHeight();

			if (NULL == m_hRgn_topleft)  // 第一次初始化四个角落和形状参数
			{
				SAFE_DELETE_GDIOBJECT(m_hRgn_topleft);
				SAFE_DELETE_GDIOBJECT(m_hRgn_topright);
				SAFE_DELETE_GDIOBJECT(m_hRgn_bottomleft);
				SAFE_DELETE_GDIOBJECT(m_hRgn_bottomright);

				RECT topleft = {0,0,m_TransparentRgn9Region.topleft, m_TransparentRgn9Region.top};
				m_hRgn_topleft = GetExcludeRgn(pBits, topleft, true);

				RECT topright = { nWindowW-m_TransparentRgn9Region.topright, 0, nWindowW, m_TransparentRgn9Region.top };
				m_hRgn_topright = GetExcludeRgn(pBits, topright, true);

				RECT bottomleft = { 0, nWindowH-m_TransparentRgn9Region.bottom, m_TransparentRgn9Region.bottomleft, nWindowH };
				m_hRgn_bottomleft = GetExcludeRgn(pBits, bottomleft, true);

				RECT bottomright = { nWindowW-m_TransparentRgn9Region.bottomright, nWindowH-m_TransparentRgn9Region.bottom, nWindowW, nWindowH };
				m_hRgn_bottomright = GetExcludeRgn(pBits, bottomright, true);
			}
 
			HRGN hRgnTopRight = ::CreateRectRgn(0,0,0,0);
			HRGN hRgnBottomLeft = ::CreateRectRgn(0,0,0,0);
			HRGN hRgnBottomRight = ::CreateRectRgn(0,0,0,0);

			// m_hRgn_xxx都是基于(0,0)坐标的，需要根据当前窗口大小进行offset操作, m_hRgn_topleft不需要offset
			::CombineRgn(hRgnTopRight,m_hRgn_topright, hRgnTopRight, RGN_COPY);
			::OffsetRgn(hRgnTopRight,nWindowW-m_TransparentRgn9Region.topright, 0);

			::CombineRgn(hRgnBottomLeft,m_hRgn_bottomleft, hRgnBottomLeft, RGN_COPY);
			::OffsetRgn(hRgnBottomLeft, 0, nWindowH-m_TransparentRgn9Region.bottom);

			::CombineRgn(hRgnBottomRight,m_hRgn_bottomright, hRgnBottomRight, RGN_COPY);
			::OffsetRgn(hRgnBottomRight, nWindowW-m_TransparentRgn9Region.bottomright, nWindowH-m_TransparentRgn9Region.bottom);

			HRGN hRgn = ::CreateRectRgn(0,0,nWindowW,nWindowH);
			::CombineRgn(hRgn, hRgn, m_hRgn_topleft,  RGN_DIFF );
			::CombineRgn(hRgn, hRgn, hRgnTopRight,    RGN_DIFF );
			::CombineRgn(hRgn, hRgn, hRgnBottomLeft,  RGN_DIFF );
			::CombineRgn(hRgn, hRgn, hRgnBottomRight, RGN_DIFF );

		//	this->SetCanRedraw(false);
			// 如果这里的参数不去刷新的话，就会在屏幕上残留下这些被裁掉的region区域。
			// MSDN: Typically, you set bRedraw to TRUE if the window is visible. 
			::SetWindowRgn(m_hWnd,hRgn, ::IsWindowVisible(m_hWnd));  
			::DeleteObject(hRgn);
		//	this->SetCanRedraw(true);

			::DeleteObject(hRgnTopRight);
			::DeleteObject(hRgnBottomLeft);
			::DeleteObject(hRgnBottomRight);
		}
		return;

	case WINDOW_TRANSPARENT_PART_8_BORDER:
		{
			// TODO: 仍有必要进行进一步的优化
			int nWindowW = this->GetWidth();
			int nWindowH = this->GetHeight();

			if (NULL == m_hRgn_topleft)  // 第一次初始化四个角落和形状参数
			{
				SAFE_DELETE_GDIOBJECT(m_hRgn_topleft);
				SAFE_DELETE_GDIOBJECT(m_hRgn_topright);
				SAFE_DELETE_GDIOBJECT(m_hRgn_bottomleft);
				SAFE_DELETE_GDIOBJECT(m_hRgn_bottomright);

				RECT topleft = {0,0,m_TransparentRgn9Region.topleft, m_TransparentRgn9Region.top};
				m_hRgn_topleft = GetExcludeRgn(pBits, topleft, true);

				RECT topright = { nWindowW-m_TransparentRgn9Region.topright, 0, nWindowW, m_TransparentRgn9Region.top };
				m_hRgn_topright = GetExcludeRgn(pBits, topright, true);

				RECT bottomleft = { 0, nWindowH-m_TransparentRgn9Region.bottom, m_TransparentRgn9Region.bottomleft, nWindowH };
				m_hRgn_bottomleft = GetExcludeRgn(pBits, bottomleft, true);

				RECT bottomright = { nWindowW-m_TransparentRgn9Region.bottomright, nWindowH-m_TransparentRgn9Region.bottom, nWindowW, nWindowH };
				m_hRgn_bottomright = GetExcludeRgn(pBits, bottomright, true);
			}

			RECT top = { m_TransparentRgn9Region.topleft, 0, nWindowW-m_TransparentRgn9Region.topright, m_TransparentRgn9Region.top };
			HRGN hRgn_top = GetExcludeRgn(pBits, top, false);
			RECT left = {0, m_TransparentRgn9Region.top, m_TransparentRgn9Region.left, nWindowH-m_TransparentRgn9Region.bottom};
			HRGN hRgn_left = GetExcludeRgn(pBits, left, false);
			RECT right = { nWindowW-m_TransparentRgn9Region.right, m_TransparentRgn9Region.top, nWindowW, nWindowH-m_TransparentRgn9Region.bottom };
			HRGN hRgn_right = GetExcludeRgn(pBits, right, false);
			RECT bottom = { m_TransparentRgn9Region.bottomleft, nWindowH-m_TransparentRgn9Region.bottomleft, nWindowW-m_TransparentRgn9Region.bottomright, nWindowH };
			HRGN hRgn_bottom = GetExcludeRgn(pBits, bottom, false);

			HRGN hRgnTopRight = ::CreateRectRgn(0,0,0,0);
			HRGN hRgnBottomLeft = ::CreateRectRgn(0,0,0,0);
			HRGN hRgnBottomRight = ::CreateRectRgn(0,0,0,0);

			// m_hRgn_xxx都是基于(0,0)坐标的，需要根据当前窗口大小进行offset操作, m_hRgn_topleft不需要offset
			::CombineRgn(hRgnTopRight,m_hRgn_topright, hRgnTopRight, RGN_COPY);
			::OffsetRgn(hRgnTopRight,nWindowW-m_TransparentRgn9Region.topright, 0);
			::CombineRgn(hRgnBottomLeft,m_hRgn_bottomleft, hRgnBottomLeft, RGN_COPY);
			::OffsetRgn(hRgnBottomLeft, 0, nWindowH-m_TransparentRgn9Region.bottom);
			::CombineRgn(hRgnBottomRight,m_hRgn_bottomright, hRgnBottomRight, RGN_COPY);
			::OffsetRgn(hRgnBottomRight, nWindowW-m_TransparentRgn9Region.bottomright, 0);

			HRGN hRgn = ::CreateRectRgn(0,0,nWindowW,nWindowH);
			::CombineRgn(hRgn, hRgn, m_hRgn_topleft,  RGN_DIFF );
			::CombineRgn(hRgn, hRgn, hRgnTopRight,    RGN_DIFF );
			::CombineRgn(hRgn, hRgn, hRgnBottomLeft,  RGN_DIFF );
			::CombineRgn(hRgn, hRgn, hRgnBottomRight, RGN_DIFF );
			::CombineRgn(hRgn, hRgn, hRgn_top,        RGN_DIFF );
			::CombineRgn(hRgn, hRgn, hRgn_left,       RGN_DIFF );
			::CombineRgn(hRgn, hRgn, hRgn_right,      RGN_DIFF );
			::CombineRgn(hRgn, hRgn, hRgn_bottom,     RGN_DIFF );

			::SetWindowRgn(m_hWnd,hRgn, ::IsWindowVisible(m_hWnd));
			::DeleteObject(hRgn);

			::DeleteObject(hRgnTopRight);
			::DeleteObject(hRgnBottomLeft);
			::DeleteObject(hRgnBottomRight);
			::DeleteObject(hRgn_top);
			::DeleteObject(hRgn_left);
			::DeleteObject(hRgn_right);
			::DeleteObject(hRgn_bottom);
			
		}
		return;

	case WINDOW_TRANSPARENT_PART_CUSTOM_CORNER:
		{
			int nWindowW = this->GetWidth();
			int nWindowH = this->GetHeight();

			if (NULL == m_hRgn_topleft && m_TransparentRgn9Region.topleft != 0 && m_TransparentRgn9Region.top != 0)
			{
				m_hRgn_topleft = ::CreateEllipticRgn( 0,0, m_TransparentRgn9Region.topleft, m_TransparentRgn9Region.top );
				HRGN hRgnRect = ::CreateRectRgn( 0,0, m_TransparentRgn9Region.topleft/2, m_TransparentRgn9Region.top/2 );
				::CombineRgn( m_hRgn_topleft, hRgnRect, m_hRgn_topleft, RGN_DIFF );
				::DeleteObject(hRgnRect);
			}
			if (NULL == m_hRgn_topright && m_TransparentRgn9Region.topright != 0 && m_TransparentRgn9Region.left != 0)
			{
				RECT rcE = {0,0, m_TransparentRgn9Region.topright, m_TransparentRgn9Region.left};
				::OffsetRect(&rcE, nWindowW-m_TransparentRgn9Region.topright, 0);
				m_hRgn_topright = ::CreateEllipticRgnIndirect( &rcE );

				RECT rcR = {0,0, m_TransparentRgn9Region.topright/2, m_TransparentRgn9Region.left/2};
				::OffsetRect(&rcR, nWindowW-m_TransparentRgn9Region.topright/2, 0 );
				HRGN hRgnRect = ::CreateRectRgnIndirect( &rcR );

				::CombineRgn( m_hRgn_topright, hRgnRect, m_hRgn_topright, RGN_DIFF );
				::DeleteObject(hRgnRect);
			}
			if (NULL == m_hRgn_bottomleft && m_TransparentRgn9Region.right != 0 && m_TransparentRgn9Region.bottomleft != 0)
			{
				RECT rcE = {0,0, m_TransparentRgn9Region.right, m_TransparentRgn9Region.bottomleft};
				::OffsetRect(&rcE, 0, nWindowH-m_TransparentRgn9Region.bottomleft);
				m_hRgn_bottomleft = ::CreateEllipticRgnIndirect(&rcE);

				RECT rcR = {0,0, m_TransparentRgn9Region.right/2, m_TransparentRgn9Region.bottomleft/2};
				::OffsetRect(&rcR, 0, nWindowH-m_TransparentRgn9Region.bottomleft/2);
				HRGN hRgnRect = ::CreateRectRgnIndirect( &rcR );
				::CombineRgn( m_hRgn_bottomleft, hRgnRect, m_hRgn_bottomleft, RGN_DIFF );
				::DeleteObject(hRgnRect);
			}
			if (NULL == m_hRgn_bottomright && m_TransparentRgn9Region.bottom != 0 && m_TransparentRgn9Region.bottomright != 0 )
			{
				RECT rcE = {0,0, m_TransparentRgn9Region.bottom, m_TransparentRgn9Region.bottomright};
				::OffsetRect(&rcE, nWindowW-m_TransparentRgn9Region.bottom, nWindowH-m_TransparentRgn9Region.bottomright );
				m_hRgn_bottomright = ::CreateEllipticRgnIndirect( &rcE );

				RECT rcR = {0,0, m_TransparentRgn9Region.bottom/2, m_TransparentRgn9Region.bottomright/2};
				::OffsetRect(&rcR,nWindowW-m_TransparentRgn9Region.bottom/2, nWindowH-m_TransparentRgn9Region.bottomright/2 );
				HRGN hRgnRect = ::CreateRectRgnIndirect( &rcR );

				::CombineRgn( m_hRgn_bottomright, hRgnRect, m_hRgn_bottomright, RGN_DIFF );
				::DeleteObject(hRgnRect);
			}

			HRGN hRgn = ::CreateRectRgn(0,0,this->GetWidth(), this->GetHeight());
			if (m_hRgn_topleft)
			{
				::CombineRgn(hRgn, hRgn, m_hRgn_topleft,  RGN_DIFF );
			}
			if (m_hRgn_topright)
			{
				::CombineRgn(hRgn, hRgn, m_hRgn_topright,  RGN_DIFF );
			}
			if (m_hRgn_bottomleft)
			{
				::CombineRgn(hRgn, hRgn, m_hRgn_bottomleft,  RGN_DIFF );
			}
			if (m_hRgn_bottomright)
			{
				::CombineRgn(hRgn, hRgn, m_hRgn_bottomright,  RGN_DIFF );
			}
			::SetWindowRgn(m_hWnd,hRgn, ::IsWindowVisible(m_hWnd));
			SAFE_DELETE_GDIOBJECT(m_hRgn_topright);
			SAFE_DELETE_GDIOBJECT(m_hRgn_bottomleft);
			SAFE_DELETE_GDIOBJECT(m_hRgn_bottomright);
		}
		return;

	}
}


//
//	从一个pBits取该内容上面RC区域内需要被抠掉的范围
//
//	bOffsetToOrigin
//		[in]	要否需要将返回的HRGN的原点设置为(0,0)开始 --- 获取四个角落的HRGN时有用
//
HRGN CustomWindow::GetExcludeRgn( BYTE* pBits, const RECT& rc, bool bOffsetToOrigin )
{
	if(NULL == pBits)
		return NULL;

	int nWindowW = this->GetWidth();
	int nWindowH = this->GetHeight();

	BYTE* p = pBits;
	vector<RECT>  vRectRgnData;
	for (LONG i = rc.top; i < rc.bottom; i++ )   
	{
		p = pBits + nWindowW*4*i + rc.left*4;
		for (LONG j = rc.left; j < rc.right; j++)      
		{
			POINT pt = { j, nWindowH-i-1 };   // 创建的m_hMemBitmap是反向的

			BYTE b = *p++;
			BYTE g = *p++;
			BYTE r = *p++;
			BYTE a = *p++;

			bool bExclude = false;
			if (((int)m_nWindowTransparentMaskType)& WINDOW_TRANSPARENT_TYPE_MASKCOLOR) 
			{
				if (NULL != m_pColMask && m_pColMask->m_col == RGB(r,g,b))
				{
					bExclude = true;
				}
			}
			if (((int)m_nWindowTransparentMaskType) & WINDOW_TRANSPARENT_TYPE_MASKALPHA)
			{
				if (a < m_nAlphaMask)
				{
					bExclude = true;
				}
			}
			if (bExclude)
			{
				RECT rcPixel = { pt.x, pt.y, pt.x+1, pt.y+1 };  // 统一设置为从0,0位置开始，便于后面的OffsetRgn
				if (bOffsetToOrigin)
				{
					::OffsetRect(&rcPixel, -rc.left, -rc.top);
				}

				vRectRgnData.push_back(rcPixel);
			}
		}
	}

	int nCount = (int)vRectRgnData.size();
	RGNDATA*   pRgnData      = (RGNDATA*)new BYTE[ sizeof(RGNDATAHEADER) + nCount*sizeof(RECT) ];
	pRgnData->rdh.dwSize     = sizeof(RGNDATAHEADER);
	pRgnData->rdh.iType      = RDH_RECTANGLES;
	pRgnData->rdh.nCount     = nCount;
	pRgnData->rdh.nRgnSize   = nCount*sizeof(RECT);
	for (int k = 0; k < nCount; k++)
	{
		RECT* prc = (RECT*)pRgnData->Buffer;
		prc[k] = vRectRgnData[k];
	}

	HRGN hRgn = ::ExtCreateRegion(NULL, sizeof(RGNDATAHEADER) + nCount*sizeof(RECT), pRgnData);
	SAFE_ARRAY_DELETE(pRgnData);

	return hRgn;
}

// void CustomWindow::EndRedrawObjectPart(IRenderTarget* pRenderTarget, RECT* prcArray, int nCount)
// {
// 	if (m_pLayeredWindowWrap)
// 	{
//         pRenderTarget->EndDraw();
//         m_pLayeredWindowWrap->Commit2LayeredWindow();
// 	}
// 	else
// 	{
//         __super::EndRedrawObjectPart(pRenderTarget, prcArray, nCount);		
// 	}
// }
void CustomWindow::CommitDoubleBuffet2Window(HDC hDCWnd, RECT* prcCommit, int nRectCount)
{
	if (m_pLayeredWindowWrap)
    {
        m_pLayeredWindowWrap->Commit2LayeredWindow();
    }
	else
    {
        __super::CommitDoubleBuffet2Window(hDCWnd, prcCommit, nRectCount);		
    }
}

//
//	获取一个POINT在CustomWindow上面的位置
//
UINT CustomWindow::OnHitTest( POINT* pt )
{
	if (m_nResizeBit == WRSB_NONE)
	{
		return HTCLIENT;
	}
 	else if (m_nResizeBit == WRSB_CAPTION)
	{
		if (NULL == GetHoverObject() && NULL == GetPressObject()  && !IsZoomed(m_hWnd))
			return HTCAPTION;
	}

	if (NULL == pt)
		return HTERROR;

	UINT nHitTest = HTCLIENT;
	if (IsZoomed(m_hWnd))
		return HTCLIENT;

	CONST int BORDER = GetSystemMetrics(SM_CYDLGFRAME)*2;

	RECT rc;
	::GetClientRect( m_hWnd, &rc );
	int nWidth  = rc.right - rc.left;
	int nHeight = rc.bottom - rc.top;

	if (pt->x < BORDER)
	{
		if (pt->y < BORDER && this->TestResizeBit(WRSB_TOPLEFT))
			nHitTest = HTTOPLEFT;
		else if (pt->y > nHeight - BORDER  && this->TestResizeBit(WRSB_BOTTOMLEFT))
			nHitTest = HTBOTTOMLEFT;
		else if (this->TestResizeBit(WRSB_LEFT))
			nHitTest = HTLEFT;
	}
	else if (pt->x > nWidth-BORDER)
	{
		if (pt->y < BORDER && this->TestResizeBit(WRSB_TOPRIGHT))
			nHitTest = HTTOPRIGHT;
		else if (pt->y > nHeight - BORDER && this->TestResizeBit(WRSB_BOTTOMRIGHT))
			nHitTest = HTBOTTOMRIGHT;
		else if (this->TestResizeBit(WRSB_RIGHT))
			nHitTest = HTRIGHT;
	}
	else if (pt->y < BORDER && this->TestResizeBit(WRSB_TOP))
	{
		nHitTest = HTTOP;
	}
	else if (pt->y > nHeight - BORDER && this->TestResizeBit(WRSB_BOTTOM))
	{
		nHitTest = HTBOTTOM;
	}
 	else
 	{
 		if (m_nResizeBit & WRSB_CAPTION && NULL == GetHoverObject() && NULL == GetPressObject() && !IsZoomed(m_hWnd))
 		{
 			nHitTest = HTCAPTION;
 		}
 	}

	return nHitTest;

}

//
//	注：这个消息其它有可能是在MOUSEMOVE之后手动POST出来的一个消息
//
BOOL CustomWindow::OnSetCursor( HWND hWnd, UINT nHitTest, UINT message )
{
	POINT pt;
	::GetCursorPos(&pt);
	::MapWindowPoints(NULL,m_hWnd,&pt,1);
	nHitTest = this->OnHitTest(&pt);
	switch(nHitTest)
	{
	case HTTOPLEFT:
	case HTBOTTOMRIGHT:
		::SetCursor( ::LoadCursor(NULL, IDC_SIZENWSE) );
		break;

	case HTTOP:
	case HTBOTTOM:
		::SetCursor( ::LoadCursor(NULL, IDC_SIZENS) );
		break;

	case HTLEFT:
	case HTRIGHT:
		::SetCursor( ::LoadCursor(NULL, IDC_SIZEWE) );
		break;

	case HTTOPRIGHT:
	case HTBOTTOMLEFT:
		::SetCursor( ::LoadCursor(NULL, IDC_SIZENESW) );
		break;

	case HTCAPTION:
		::SetCursor( ::LoadCursor(NULL, IDC_ARROW) );
		break;

	default:
		::SetCursor( ::LoadCursor(NULL, IDC_ARROW) );
		break;	
	}
	
	return TRUE;
}

//
//	使用通过在 NCHitTest中返回HTCAPTION也能使用点击拖拽的效果，但缺点是会一直产生一个WM_MOUSELEAVE消息，因为鼠标不在客户区域了
//
//	使用WS_THICKFRAME也可以直接实现边框拖拽效果，但还需要去响应NCCACLSIZE和添加一个属性，可能会导致窗口在WIN7下面显示透明边框
//	
//  另外UpdateLayeredWindow支持更平滑的窗口拉伸效果，因此对于分层窗口的拉伸是另外一套逻辑实现的
//
void CustomWindow::OnLButtonDown(UINT nFlags, POINT pt)
{
	SetMsgHandled(FALSE);

	UINT nHitTest = this->OnHitTest(&pt);

	switch(nHitTest)
	{
	case HTTOPLEFT:
		if (m_pLayeredWindowWrap)
			m_pLayeredWindowWrap->OnLButtonDown(nHitTest);
		else
			::PostMessage( m_hWnd, WM_SYSCOMMAND, SC_SIZE|WMSZ_TOPLEFT, MAKELPARAM(pt.x,pt.y) );
		break;

	case HTTOP:
		if (m_pLayeredWindowWrap)
			m_pLayeredWindowWrap->OnLButtonDown(nHitTest);
		else
			::PostMessage( m_hWnd, WM_SYSCOMMAND, SC_SIZE|WMSZ_TOP, MAKELPARAM(pt.x,pt.y) );
		break;

	case HTTOPRIGHT:
		if (m_pLayeredWindowWrap)
			m_pLayeredWindowWrap->OnLButtonDown(nHitTest);
		else
			::PostMessage( m_hWnd, WM_SYSCOMMAND, SC_SIZE|WMSZ_TOPRIGHT, MAKELPARAM(pt.x,pt.y) );
		break;

	case HTLEFT:
		if (m_pLayeredWindowWrap)
			m_pLayeredWindowWrap->OnLButtonDown(nHitTest);
		else
			::PostMessage( m_hWnd, WM_SYSCOMMAND, SC_SIZE|WMSZ_LEFT, MAKELPARAM(pt.x,pt.y) );
		break;

	case HTRIGHT:
		if (m_pLayeredWindowWrap)
			m_pLayeredWindowWrap->OnLButtonDown(nHitTest);
		else
			::PostMessage( m_hWnd, WM_SYSCOMMAND, SC_SIZE|WMSZ_RIGHT, MAKELPARAM(pt.x,pt.y) );
		break;

	case HTBOTTOMLEFT:
		if (m_pLayeredWindowWrap)
			m_pLayeredWindowWrap->OnLButtonDown(nHitTest);
		else
			::PostMessage( m_hWnd, WM_SYSCOMMAND, SC_SIZE|WMSZ_BOTTOMLEFT, MAKELPARAM(pt.x,pt.y) );
		break;

	case HTBOTTOM:
		if (m_pLayeredWindowWrap)
			m_pLayeredWindowWrap->OnLButtonDown(nHitTest);
		else
			::PostMessage( m_hWnd, WM_SYSCOMMAND, SC_SIZE|WMSZ_BOTTOM, MAKELPARAM(pt.x,pt.y) );
		break;

	case HTBOTTOMRIGHT:
		if (m_pLayeredWindowWrap)
			m_pLayeredWindowWrap->OnLButtonDown(nHitTest);
		else
			::PostMessage( m_hWnd, WM_SYSCOMMAND, SC_SIZE|WMSZ_BOTTOMRIGHT, MAKELPARAM(pt.x,pt.y) );
		break;

	case HTCAPTION:
		{
			::PostMessage( m_hWnd, WM_NCLBUTTONDOWN, HTCAPTION, MAKELPARAM(pt.x,pt.y) );
		}
		break;
	}
}

void CustomWindow::OnLButtonUp(UINT nFlags, POINT point)
{
	SetMsgHandled(FALSE);
	if (m_pLayeredWindowWrap)
	{
		m_pLayeredWindowWrap->OnLButtonUp();
	}
}

void  CustomWindow::OnMouseMove(UINT nFlags, POINT point)
{
	SetMsgHandled(FALSE);

	if (m_pLayeredWindowWrap)
	{
		m_pLayeredWindowWrap->OnMouseMove();
	}
}

// 注：不要响应UIMSG的WM_SIZE。因为在WindowBase::_OnSize中就已经开始更新窗口了，因
//     此需要在那之前将m_bNeedToSetWindowRgn标志置上。否则将光置上标志，却错过了OnEndEraseBknd
LRESULT  CustomWindow::_OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	bHandled = FALSE;

	// 最小化和从最小化还原时，不需要重新计算窗口的形状
	if (SIZE_MINIMIZED == wParam || (SIZE_RESTORED==wParam && ::IsIconic(m_hWnd)))
		return 0;

	this->m_bNeedToSetWindowRgn = true;
    return 0;
}

//
//	设置窗口是否可以拖拽
//
void CustomWindow::SetWindowResizeType( UINT nType )
{
	m_nResizeBit = nType;
}

//
// 判断窗口的拉伸状态位
//
bool  CustomWindow::TestResizeBit( int nBit )
{
	if (m_nResizeBit & nBit)
		return true;
	else 
		return false;
}


bool  CustomWindow::IsWindowLayered()
{
	return (NULL!=m_pLayeredWindowWrap);
}
//
//	设置/取消一个窗口为分层窗口
//
//	Remark
//		如果一个窗口需要在分层与非分层之间进行切换的话，则必须响应 UI_WM_GET_GRAPHICS_RENDER_LIBRARY_TYPE 消息，
//		并返回RENDER_TYPE_GDIPLUS类型。因为目前不支持切换为分层窗口时，将该窗口中所使用到的
//		图片、字体资源都同时转换成GDIPLUS类型的。
//
void  CustomWindow::SetWindowLayered(bool b)
{
	if (b && NULL != m_pLayeredWindowWrap)
		return;
	if (!b && NULL == m_pLayeredWindowWrap)
		return;

	if (b)
	{
		m_pLayeredWindowWrap = new LayeredWindowWrap(this);
		m_nWindowTransparentMaskType |= WINDOW_TRANSPARENT_TYPE_LAYERED;
		if (0 == (m_nWindowTransparentMaskType & WINDOW_TRANSPARENT_TYPE_MASKALPHA) &&
            0 == (m_nWindowTransparentMaskType & WINDOW_TRANSPARENT_TYPE_MASKCOLOR))
		{
			m_nWindowTransparentMaskType |= WINDOW_TRANSPARENT_TYPE_MASKALPHA;  // 避免忘记了设置该项，否则Commit的时候参数不正确
			m_nAlphaMask = 255;
		}

		// 使用分层窗口的话，就不要再显示窗口阴影了。（场景：菜单窗口默认是带SHADOW的，使用分层窗口时就不需要这个阴影了，自己模拟即可）
		SetClassLong(m_hWnd, GCL_STYLE, GetClassLong(m_hWnd, GCL_STYLE)&~CS_DROPSHADOW);

		SetWindowLong(m_hWnd, 
			GWL_EXSTYLE,
			GetWindowLong(m_hWnd, GWL_EXSTYLE) | WS_EX_LAYERED);

		SetWindowRgn(m_hWnd, NULL, FALSE);   // 取消窗口的异形，由分层窗口自己来处理。分层窗口仅会收到一个WINDOWPOSCHANGED消息，但SWP_NOSIZE，因此还需要另外发送一个
		                                     // 窗口大小的消息告诉分层窗口当前大小
		m_pRenderChain->GetWindowLayer()->ReCreateRenderTarget();  //放在InitLayeredWindow的前面，避免在InitLayeredWindow->Invalidate->WM_PAINT中创建的RenderTarget又被销毁了
		m_pLayeredWindowWrap->InitLayeredWindow();
	}
	else
	{
		m_nWindowTransparentMaskType &= ~WINDOW_TRANSPARENT_TYPE_LAYERED;
		// 注：直接去除WS_EX_LAYERED属性，会导致窗口先变黑，然后再刷新一次。
		//     因此在这里去除分层属性之后，直接将mem bitmap的内容先画到窗口上来规避这个问题。
		//     同时为了解决画到窗口上的内容有rgn以外的部分，在去除分层属性之前，先计算
		//     窗口的形状
		
		this->UpdateWindowRgn();

		// Remove WS_EX_LAYERED from this window styles
		SetWindowLong(m_hWnd, 
			GWL_EXSTYLE,
			GetWindowLong(m_hWnd, GWL_EXSTYLE) & ~WS_EX_LAYERED);

		HDC hDC = ::GetDC(m_hWnd);
		::BitBlt(hDC,0,0, GetWidth(), GetHeight(), m_pRenderChain->GetMemoryDC(), 0,0, SRCCOPY);
		ReleaseDC(m_hWnd, hDC);

		m_pLayeredWindowWrap->ReleaseLayeredWindow();
		SAFE_DELETE(m_pLayeredWindowWrap);

		// Ask the window and its children to repaint (Bitblt已完成了刷新功能)
// 		RedrawWindow(m_hWnd, 
// 			NULL, 
// 			NULL, 
// 			RDW_ERASE | RDW_INVALIDATE | RDW_FRAME | RDW_ALLCHILDREN);
		
		m_pRenderChain->GetWindowLayer()->ReCreateRenderTarget();
	}
    if (m_nWindowTransparentMaskType & WINDOW_TRANSPARENT_TYPE_LAYERED || 
        m_nWindowTransparentMaskType & WINDOW_TRANSPARENT_TYPE_AREO)
        this->SetTransparent(true); // 借用该标识位，外部通过判断IsTransparent来得到窗口是否是分层窗口。例如每次是否需要清空缓存，避免alpha叠加
    else
        this->SetTransparent(false);

    UIMSG  msg;
    msg.message = UI_WM_WINDOWLAYEREDCHANGED;
    msg.wParam = (WPARAM)b;
    msg.lParam = 0;
    Message::ForwardMessageToChildObject(this, &msg);
}

void  CustomWindow::SetWindowAreo(bool b)
{
    DwmHelper* pDwm = DwmHelper::GetInstance();
    if (b)
    {
        m_nWindowTransparentMaskType |= WINDOW_TRANSPARENT_TYPE_AREO;
        if (pDwm->IsEnable())
        {
            // 恢复成支持areo的主题了，可以不用使用layered
            if (m_nWindowTransparentMaskType & WINDOW_TRANSPARENT_TYPE_LAYERED)
            {
                SetWindowLayered(false);
            }

            UpdateWindowRgn();
        }
        else
        {
			if (pDwm->pDwmEnableBlurBehindWindow)
			{
				DWM_BLURBEHIND blurbehind = {0};
				blurbehind.dwFlags = DWM_BB_ENABLE;
				blurbehind.fEnable = FALSE;
				pDwm->pDwmEnableBlurBehindWindow(m_hWnd, &blurbehind);
			}

            // 不支持areo， 用分层窗口代替
            SetWindowLayered(true);
        }
    }
    else
    {
        if (m_nWindowTransparentMaskType & WINDOW_TRANSPARENT_TYPE_AREO)
        {
            m_nWindowTransparentMaskType &= ~WINDOW_TRANSPARENT_TYPE_AREO;

            if (pDwm->pDwmEnableBlurBehindWindow)
            {
                DWM_BLURBEHIND blurbehind = {0};
                blurbehind.dwFlags = DWM_BB_ENABLE;
                blurbehind.fEnable = FALSE;
                pDwm->pDwmEnableBlurBehindWindow(m_hWnd, &blurbehind);
            }
        }
    }
}

void  CustomWindow::SetWindowTransparentMaskType(int type)
{
	m_nWindowTransparentMaskType = type;
}
int   CustomWindow::GetWindowTransparentMaskType()
{
    return m_nWindowTransparentMaskType;
}
void  CustomWindow::SetWindowTransparentColMask( COLORREF col )
{
    SAFE_RELEASE(m_pColMask);
    m_pColMask = Color::CreateInstance(col);
}
void  CustomWindow::SetWindowTransparentColMask( const String& strColdID )
{
	if (NULL == m_pUIApplication)
		return ;

	IColorRes* pColorRes = m_pUIApplication->GetActiveSkinColorRes();
	if (pColorRes)
		pColorRes->GetColor((BSTR)strColdID.c_str(), &m_pColMask);
}
void  CustomWindow::SetWindowTransparentAlphaMask( int nAlpha )
{
	m_nAlphaMask = nAlpha;
}

// -> 注：每次强制返回HTCAPTION之后，将导致生成WM_MOUSELEAVE消息（鼠标进入非客户区域 )
// 当鼠标不再窗口控件上的位置拖动时候，默认拖动窗口
//LRESULT  CustomWindow::OnNcHitTest( POINT pt )
//{
// 	if (NULL == MouseManager::GetObjectByPos( this->GetWindowObject(), &pt))
// 	{
// 		__super::SetMsgHandled(TRUE);
// 		return HTCAPTION;
// 	}
// 	return HTCLIENT;
//}


/*  注：Removed. 改进：不再通过使用OnNcHitTest返回HTCAPTION来实现拖拽
	目的：在使用CustomWindow/CustomExWindow的时候，如果鼠标拖动的client区域没有其他控件
	      则 OnNcHitTest 会返回 HTCAPTION 。
		  这样就会产生一个问题：返回HTCAPTION之后，就不会产生 WM_MOUSEMOVE消息，而是会
		  产生 WM_NCMOUSEMOVE 消息，这就给 MouseManager 在处理 WM_MOUSEMOVE 消息时带来
		  了错误。因此有必要在 Custom(Ex)Window中将 WM_NCXXX消息再转换成 WM_XXX消息
*/

// void CustomWindow::OnNcMouseMove( UINT nHitTest, POINT point )
// {
// 	SetMsgHandled(FALSE);
// 	::MapWindowPoints( NULL, m_hWnd, &point, 1 );
// 	::SendMessage( m_hWnd, WM_MOUSEMOVE, (WPARAM)nHitTest, MAKELPARAM(point.x,point.y) );
// }
// void CustomWindow::OnNcMouseHover( UINT nHitTest, POINT point )
// {
// 	SetMsgHandled(FALSE);
// 	::MapWindowPoints( NULL, m_hWnd, &point, 1 );
// 	::SendMessage( m_hWnd, WM_MOUSEHOVER, (WPARAM)nHitTest, MAKELPARAM(point.x,point.y) );
// }
// void CustomWindow::OnNcMouseLeave()
// {
// 	SetMsgHandled(FALSE);
// 	::SendMessage( m_hWnd, WM_MOUSELEAVE, (WPARAM)0, (LPARAM)0 );
// }
// void CustomWindow::OnNcLButtonDown( UINT nHitTest, POINT point )
// {
// 	SetMsgHandled(FALSE);
// 	::MapWindowPoints( NULL, m_hWnd, &point, 1 );
// 	::SendMessage( m_hWnd, WM_LBUTTONDOWN, (WPARAM)nHitTest, MAKELPARAM(point.x,point.y) );
// }
// void CustomWindow::OnNcLButtonUp( UINT nHitTest, POINT point )
// {
// 	SetMsgHandled(FALSE);
// 	::MapWindowPoints( NULL, m_hWnd, &point, 1 );
// 	::SendMessage( m_hWnd, WM_LBUTTONUP, (WPARAM)nHitTest, MAKELPARAM(point.x,point.y) );
// }
// void CustomWindow::OnNcLButtonDblClk( UINT nHitTest, POINT point )
// {
// 	SetMsgHandled(FALSE);
// 	::MapWindowPoints( NULL, m_hWnd, &point, 1 );
// 	::SendMessage( m_hWnd, WM_LBUTTONDBLCLK, (WPARAM)nHitTest, MAKELPARAM(point.x,point.y) );
// }
// void CustomWindow::OnNcRButtonDown( UINT nHitTest, POINT point )
// {
// 	SetMsgHandled(FALSE);
// 	::MapWindowPoints( NULL, m_hWnd, &point, 1 );
// 	::SendMessage( m_hWnd, WM_RBUTTONDOWN, (WPARAM)nHitTest, MAKELPARAM(point.x,point.y) );
// }
// void CustomWindow::OnNcRButtonUp( UINT nHitTest, POINT point )
// {
// 	SetMsgHandled(FALSE);
// 	::MapWindowPoints( NULL, m_hWnd, &point, 1 );
// 	::SendMessage( m_hWnd, WM_RBUTTONUP, (WPARAM)nHitTest, MAKELPARAM(point.x,point.y) );
// }
// void CustomWindow::OnNcRButtonDblClk( UINT nHitTest, POINT point )
// {
// 	SetMsgHandled(FALSE);
// 	::MapWindowPoints( NULL, m_hWnd, &point, 1 );
// 	::SendMessage( m_hWnd, WM_RBUTTONDBLCLK, (WPARAM)nHitTest, MAKELPARAM(point.x,point.y) );
// }
// void CustomWindow::OnNcMButtonDown( UINT nHitTest, POINT point )
// {
// 	SetMsgHandled(FALSE);
// 	::MapWindowPoints( NULL, m_hWnd, &point, 1 );
// 	::SendMessage( m_hWnd, WM_MBUTTONDOWN, (WPARAM)nHitTest, MAKELPARAM(point.x,point.y) );
// }
// void CustomWindow::OnNcMButtonUp( UINT nHitTest, POINT point )
// {
// 	SetMsgHandled(FALSE);
// 	::MapWindowPoints( NULL, m_hWnd, &point, 1 );
// 	::SendMessage( m_hWnd, WM_MBUTTONUP, (WPARAM)nHitTest, MAKELPARAM(point.x,point.y) );
// }
// void CustomWindow::OnNcMButtonDblClk( UINT nHitTest, POINT point )
// {
// 	SetMsgHandled(FALSE);
// 	::MapWindowPoints( NULL, m_hWnd, &point, 1 );
// 	::SendMessage( m_hWnd, WM_MBUTTONDBLCLK, (WPARAM)nHitTest, MAKELPARAM(point.x,point.y) );
// }


//////////////////////////////////////////////////////////////////////////


LayeredWindowWrap::LayeredWindowWrap(CustomWindow* pWindow)
{
	m_pWindow = pWindow;

	m_nHitTestFlag = 0;
	m_ptStartSizeMove.x = 0;
	m_ptStartSizeMove.y = 0;
	m_ptWindowOld.x = 0;
	m_ptWindowOld.y = 0;
	m_sizeWindowOld.cx = 0;
	m_sizeWindowOld.cy = 0;
	m_ptWindow.x = NDEF;
	m_ptWindow.y = NDEF;
	m_sizeWindow.cx = NDEF;
	m_sizeWindow.cy = NDEF;
}
LayeredWindowWrap::~LayeredWindowWrap()
{
	m_pWindow = NULL;
}
BOOL  LayeredWindowWrap::PreCreateWindow(CREATESTRUCT* pcs)
{
	// 添加分层属性 
	pcs->dwExStyle |= WS_EX_LAYERED;
	return TRUE;
}


void  LayeredWindowWrap::InitLayeredWindow()
{
	CRect rc;
	::GetWindowRect(m_pWindow->m_hWnd, &rc );

	// 避免因为在SetLayerWindowd(true)之前错过了带在设置SIZE的WindowPosChanged消息，
	// 在这里检测一次
	if (NDEF == m_sizeWindow.cx && NDEF == m_sizeWindow.cy)
	{
		m_sizeWindow.cx = rc.Width();
		m_sizeWindow.cy = rc.Height();
	}
	if (NDEF == m_ptWindow.x && NDEF == m_ptWindow.y)
	{
		m_ptWindow.x = rc.left;
		m_ptWindow.y = rc.top;
	}
}
void  LayeredWindowWrap::ReleaseLayeredWindow()
{
}

void  LayeredWindowWrap::OnWindowPosChanging(LPWINDOWPOS lpWndPos)
{
// 	if (lpWndPos->flags & SWP_SHOWWINDOW)  // 窗口显示（窗口隐藏时，DrawObject会失败）
// 	{
// 		this->RedrawObject(m_pWindow, TRUE);
// 	}
}
void  LayeredWindowWrap::OnWindowPosChanged(LPWINDOWPOS lpWndPos)
{
    // 最小化了，仅保存一下m_ptWindow，用于后面判断是否是最小化，不修改m_sizeWindow（不好处理）
    if (lpWndPos->x == WINDOWS_MINIMIZED_POINT && lpWndPos->y == WINDOWS_MINIMIZED_POINT)
    {
        m_ptWindow.x = WINDOWS_MINIMIZED_POINT;
        m_ptWindow.y = WINDOWS_MINIMIZED_POINT;
    }
    else
    {
	    if (!(lpWndPos->flags & SWP_NOMOVE))
	    {
		    m_ptWindow.x = lpWndPos->x;
		    m_ptWindow.y = lpWndPos->y;
	    }
	    if (!(lpWndPos->flags & SWP_NOSIZE))
	    {
		    m_sizeWindow.cx = lpWndPos->cx;
		    m_sizeWindow.cy = lpWndPos->cy;
	    }
	    if (lpWndPos->flags & SWP_SHOWWINDOW)  // 窗口显示（窗口隐藏时，DrawObject会失败）
	    {
            ::InvalidateRect(m_pWindow->m_hWnd, NULL, TRUE);
	    }
    }
}

// 模拟拖拽窗口拉伸过程
void  LayeredWindowWrap::OnLButtonDown(UINT nHitTest)
{
	OnEnterSizeMove(nHitTest);
}
void  LayeredWindowWrap::OnLButtonUp()
{
	OnExitSizeMove();
}
void  LayeredWindowWrap::OnCancelMode()
{
	OnExitSizeMove();
}
void  LayeredWindowWrap::OnMouseMove()
{
	if (0 == m_nHitTestFlag)
		return;

	POINT ptCursor;
	GetCursorPos(&ptCursor);

	int nxMoveDiff = 0;
	int nyMoveDiff = 0;

	int oldCX = m_sizeWindow.cx;
	int oldCY = m_sizeWindow.cy;

	// 计算窗口的新坐标 (注：对于向左/上拉伸时，如果限制了最大宽/高，则在计算坐标时需要按照最大宽/高来计算，而不是鼠标位置)
	switch(m_nHitTestFlag)
	{
	case HTLEFT:
		nxMoveDiff = m_ptStartSizeMove.x - ptCursor.x;
		m_sizeWindow.cx = m_sizeWindowOld.cx + nxMoveDiff;
	
		if (m_pWindow->m_nMaxWidth != NDEF && m_sizeWindow.cx > m_pWindow->m_nMaxWidth)
			m_sizeWindow.cx = m_pWindow->m_nMaxWidth;
		if (m_pWindow->m_nMinWidth != NDEF && m_sizeWindow.cx < m_pWindow->m_nMinWidth)
			m_sizeWindow.cx = m_pWindow->m_nMinWidth;

		m_ptWindow.x = m_ptWindowOld.x + m_sizeWindowOld.cx - m_sizeWindow.cx;
		
		break;

	case HTRIGHT:
		nxMoveDiff = ptCursor.x - m_ptStartSizeMove.x;
		m_sizeWindow.cx = m_sizeWindowOld.cx + nxMoveDiff;
		break;

	case HTTOP:
		nyMoveDiff = m_ptStartSizeMove.y - ptCursor.y;
		m_sizeWindow.cy = m_sizeWindowOld.cy + nyMoveDiff;

		if (m_pWindow->m_nMaxHeight != NDEF && m_sizeWindow.cy > m_pWindow->m_nMaxHeight)
			m_sizeWindow.cy = m_pWindow->m_nMaxHeight;
		if (m_pWindow->m_nMinHeight != NDEF && m_sizeWindow.cy < m_pWindow->m_nMinHeight)
			m_sizeWindow.cy = m_pWindow->m_nMinHeight;

		m_ptWindow.y = m_ptWindowOld.y+m_sizeWindowOld.cy - m_sizeWindow.cy;

		break;

	case HTBOTTOM:
		nyMoveDiff = ptCursor.y - m_ptStartSizeMove.y;
		m_sizeWindow.cy = m_sizeWindowOld.cy + nyMoveDiff;
		break;

	case HTTOPLEFT:
		nxMoveDiff = m_ptStartSizeMove.x - ptCursor.x;
		m_sizeWindow.cx = m_sizeWindowOld.cx + nxMoveDiff;

		nyMoveDiff = m_ptStartSizeMove.y - ptCursor.y;
		m_sizeWindow.cy = m_sizeWindowOld.cy + nyMoveDiff;

		if (m_pWindow->m_nMaxWidth != NDEF && m_sizeWindow.cx > m_pWindow->m_nMaxWidth)
			m_sizeWindow.cx = m_pWindow->m_nMaxWidth;
		if (m_pWindow->m_nMaxHeight != NDEF && m_sizeWindow.cy > m_pWindow->m_nMaxHeight)
			m_sizeWindow.cy = m_pWindow->m_nMaxHeight;
		if (m_pWindow->m_nMinWidth != NDEF && m_sizeWindow.cx < m_pWindow->m_nMinWidth)
			m_sizeWindow.cx = m_pWindow->m_nMinWidth;
		if (m_pWindow->m_nMinHeight != NDEF && m_sizeWindow.cy < m_pWindow->m_nMinHeight)
			m_sizeWindow.cy = m_pWindow->m_nMinHeight;

		m_ptWindow.y = m_ptWindowOld.y+m_sizeWindowOld.cy - m_sizeWindow.cy;
		m_ptWindow.x = m_ptWindowOld.x + m_sizeWindowOld.cx - m_sizeWindow.cx;
		
		break;

	case HTTOPRIGHT:
		nxMoveDiff = ptCursor.x - m_ptStartSizeMove.x;
		m_sizeWindow.cx = m_sizeWindowOld.cx + nxMoveDiff;

		nyMoveDiff = m_ptStartSizeMove.y - ptCursor.y;
		m_sizeWindow.cy = m_sizeWindowOld.cy + nyMoveDiff;

		if (m_pWindow->m_nMaxHeight != NDEF && m_sizeWindow.cy > m_pWindow->m_nMaxHeight)
			m_sizeWindow.cy = m_pWindow->m_nMaxHeight;
		if (m_pWindow->m_nMinHeight != NDEF && m_sizeWindow.cy < m_pWindow->m_nMinHeight)
			m_sizeWindow.cy = m_pWindow->m_nMinHeight;

		m_ptWindow.y = m_ptWindowOld.y+m_sizeWindowOld.cy - m_sizeWindow.cy;
		break;

	case HTBOTTOMLEFT:
		nxMoveDiff = m_ptStartSizeMove.x - ptCursor.x;
		m_sizeWindow.cx = m_sizeWindowOld.cx + nxMoveDiff;

		if (m_pWindow->m_nMaxWidth != NDEF && m_sizeWindow.cx > m_pWindow->m_nMaxWidth)
			m_sizeWindow.cx = m_pWindow->m_nMaxWidth;
		if (m_pWindow->m_nMinWidth != NDEF && m_sizeWindow.cx < m_pWindow->m_nMinWidth)
			m_sizeWindow.cx = m_pWindow->m_nMinWidth;

		m_ptWindow.x = m_ptWindowOld.x + m_sizeWindowOld.cx - m_sizeWindow.cx;

		nyMoveDiff = ptCursor.y - m_ptStartSizeMove.y;
		m_sizeWindow.cy = m_sizeWindowOld.cy + nyMoveDiff;
		break;

	case HTBOTTOMRIGHT:
		nxMoveDiff = ptCursor.x - m_ptStartSizeMove.x;
		m_sizeWindow.cx = m_sizeWindowOld.cx + nxMoveDiff;

		nyMoveDiff = ptCursor.y - m_ptStartSizeMove.y;
		m_sizeWindow.cy = m_sizeWindowOld.cy + nyMoveDiff;
		break;
	}

	// 限制窗口大小
	if (m_pWindow->m_nMaxWidth != NDEF && m_sizeWindow.cx > m_pWindow->m_nMaxWidth)
		m_sizeWindow.cx = m_pWindow->m_nMaxWidth;
	if (m_pWindow->m_nMaxHeight != NDEF && m_sizeWindow.cy > m_pWindow->m_nMaxHeight)
		m_sizeWindow.cy = m_pWindow->m_nMaxHeight;
	if (m_pWindow->m_nMinWidth != NDEF && m_sizeWindow.cx < m_pWindow->m_nMinWidth)
		m_sizeWindow.cx = m_pWindow->m_nMinWidth;
	if (m_pWindow->m_nMinHeight != NDEF && m_sizeWindow.cy < m_pWindow->m_nMinHeight)
		m_sizeWindow.cy = m_pWindow->m_nMinHeight;

	if (oldCX == m_sizeWindow.cx && oldCY == m_sizeWindow.cy)
	{
		return;
	}


	m_pWindow->SetCanRedraw(false);  // 缓存被清空，防止此期间有object redraw,提交到窗口时，数据不完整。
	//m_pWindow->CreateDoubleBuffer(m_sizeWindow.cx, m_sizeWindow.cy);
	m_pWindow->m_pRenderChain->OnWindowResize(0, m_sizeWindow.cx, m_sizeWindow.cy);

	// 注意：m_rcParent的更新千万不能使用GetWindowRect。因为窗口的大小现在就没有变
	//       所以这里也就没有采用SendMessage(WM_SIZE)的方法
	SetRect(&m_pWindow->m_rcParent, 0,0, m_sizeWindow.cx, m_sizeWindow.cy);
	m_pWindow->UpdateLayout(false);

	m_pWindow->SetCanRedraw(true);
	m_pWindow->UpdateObject();

	// 模拟窗口大小改变消息
	// PS: 20130108 17:07 将消息发送的时机移到OnSize之后。
	//     主要是因为在OnSize中，会触发richedit的setcaretpos通知，然后此时窗口的大小还没有真正改变，
	//     因此在CCaretWindow::SetCaretPos中调用MapWindowPoints获取到的光标屏幕位置还是旧的，导致光标
	//     跟随窗口移动失败。因此将CCaretWindow::OnSyncWindowPosChanging延后来修正这个问题。
	{
		MSG  msg;
		msg.hwnd = m_pWindow->m_hWnd;
		msg.message = WM_WINDOWPOSCHANGING;
		msg.wParam = 0;

		WINDOWPOS  wndpos;
		memset(&wndpos, 0, sizeof(&wndpos));
		wndpos.hwnd = msg.hwnd;
		wndpos.flags = SWP_LAYEREDWINDOW_SIZEMOVE|SWP_NOZORDER|SWP_NOACTIVATE|SWP_NOSENDCHANGING;
		wndpos.x = m_ptWindow.x;
		wndpos.y = m_ptWindow.y;
		wndpos.cx = m_sizeWindow.cx;
		wndpos.cy = m_sizeWindow.cy;
		msg.lParam = (LPARAM)&wndpos;
		::SendMessage(msg.hwnd, msg.message, msg.wParam, msg.lParam);
	}
}
void  LayeredWindowWrap::OnEnterSizeMove(UINT nHitTest)
{
	SetCapture(m_pWindow->m_hWnd);
	m_nHitTestFlag = nHitTest;

	POINT ptWindow;
	GetCursorPos(&ptWindow);

	m_ptStartSizeMove.x = ptWindow.x;
	m_ptStartSizeMove.y = ptWindow.y;

	m_ptWindowOld.x = m_ptWindow.x;
	m_ptWindowOld.y = m_ptWindow.y;
	m_sizeWindowOld.cx = m_sizeWindow.cx;
	m_sizeWindowOld.cy = m_sizeWindow.cy;
}

void  LayeredWindowWrap::OnExitSizeMove()
{
	if (0 == m_nHitTestFlag)
		return;

	if (m_pWindow->m_hWnd == GetCapture())
		ReleaseCapture();

	m_nHitTestFlag = 0;
	m_ptStartSizeMove.x = 0;
	m_ptStartSizeMove.y = 0;

	m_ptWindowOld.x = 0;
	m_ptWindowOld.y = 0;
	m_sizeWindowOld.cx = 0;
	m_sizeWindowOld.cy = 0;
}

// 当窗口最小化了的时候，如果再次用原point/size, Commit，会导致窗口又恢复到最小化之前的位置
// 因此增加一个标志，如果窗口最小化了，则不修改窗口位置，仅在原窗口大小上面提交
bool  LayeredWindowWrap::IsMinimized()
{
    if (m_ptWindow.x == WINDOWS_MINIMIZED_POINT && m_ptWindow.y == WINDOWS_MINIMIZED_POINT)
        return true;

    return false;
};

void  LayeredWindowWrap::Commit2LayeredWindow()
{
	// 主要是为了防止在分层窗口大小改变时，需要重新创建缓存，
	// 在缓存完整绘制完一次之前禁止提交到窗口上
	if (!m_pWindow->CanRedraw())  
		return; 

	POINT ptMemDC  = {0,0};
	int   nFlag = ULW_OPAQUE;
	DWORD dwColorMask = 0;

	BLENDFUNCTION bf;
	bf.BlendOp     = AC_SRC_OVER ;
	bf.AlphaFormat = AC_SRC_ALPHA;        // AC_SRC_ALPHA 会导致窗口被搂空,AC_SRC_OVER不使用透明
	bf.BlendFlags  = 0;                   // Must be zero. 
	bf.SourceConstantAlpha = 255;         // 0~255 透明度

	// TODO [注：在xp、win7不使用桌面主题的情况下，COLOR将有问题，因此建议全部使用PNG来实现透明
	if (m_pWindow->m_nWindowTransparentMaskType & WINDOW_TRANSPARENT_TYPE_MASKALPHA)
	{
		nFlag &= ~ULW_OPAQUE;
		nFlag |= ULW_ALPHA;
		bf.SourceConstantAlpha = m_pWindow->m_nAlphaMask;
	}
	else if (m_pWindow->m_nWindowTransparentMaskType & WINDOW_TRANSPARENT_TYPE_MASKCOLOR) 
	{
		if (m_pWindow->m_pColMask)
		{
			dwColorMask = m_pWindow->m_pColMask->m_col;
			nFlag = ULW_COLORKEY;
		}
	}

    // 最小化了也要刷新，否则最还原之后会发现画面不连贯了。因为在显示出来的那一瞬间，还是最小化前的画面
     BOOL  bRet = ::UpdateLayeredWindow(
                        m_pWindow->m_hWnd, NULL, 
                        IsMinimized() ? NULL : &m_ptWindow, 
                        &m_sizeWindow, 
                        m_pWindow->m_pRenderChain->GetMemoryDC(), 
                        &ptMemDC, dwColorMask, &bf, nFlag); 

//  m_pWindow->m_pRenderChain->GetMemoryBuffer()->Save(L"C:\\aaa.png", Gdiplus::ImageFormatPNG);
	if (FALSE == bRet)
	{
		UI_LOG_ERROR(_T("%s UpdateLayeredWindow Failed."), FUNC_NAME);
	}
}
